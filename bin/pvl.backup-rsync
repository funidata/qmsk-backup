#!/usr/bin/python

"""
    SSH authorized_keys command="..." wrapper for rsync.

    Testing goes something like:
        sudo PYTHONPATH=. ./bin/pvlbackup-rsync-wrapper --command 'rsync --server --sender -ax . lvm:asdf:test' -vD

        sudo sh -c "PYTHONPATH=. rsync -e './bin/pvlbackup-rsync-wrapper --debug -C --' -ax testing:lvm:asdf:test test/tmp"
"""

from pvl.backup import __version__
from pvl.backup.rsync import RSyncCommandFormatError
from pvl.backup.invoke import InvokeError
from pvl.backup import rsync, lvm

import optparse
import shlex
import os
import logging

log = logging.getLogger()

def parse_options (argv) :
    """
        Parse command-line arguments.
    """

#    import sys; sys.stderr.write("%s\n" % (argv, ))

    parser = optparse.OptionParser(
            prog        = argv[0],

            # module docstring
            description = __doc__,
            version     = __version__,
    )

    # logging
    general = optparse.OptionGroup(parser, "General Options")

    general.add_option('-q', '--quiet',      dest='loglevel', action='store_const', const=logging.WARNING, help="Less output")
    general.add_option('-v', '--verbose',    dest='loglevel', action='store_const', const=logging.INFO,  help="More output")
    general.add_option('-D', '--debug',      dest='loglevel', action='store_const', const=logging.DEBUG, help="Even more output")
    general.add_option('--debug-for',        action='append', metavar='MODULE', help="Enable logging for the given logger/module name")

    parser.add_option_group(general)

    #
    parser.add_option('-c', '--command',    metavar='CMD', default=os.environ.get('SSH_ORIGINAL_COMMAND'),
            help="rsync command to execute")

    parser.add_option('-C', '--given-command', action='store_true', default=False,
            help="use given command in `rsync -e %prog` format")

    parser.add_option('-n', '--noop', action='store_true', default=False,
            help="Parse command, but do not execute")

    parser.add_option('-R', '--readonly',   action='store_true', default=False,
            help="restrict to read/source mode")

    parser.add_option('-P', '--restrict-path', metavar='PATH', default=False,
            help="restrict to given path prefix")

    # lvm options
    parser.add_option('-L', '--snapshot-size', metavar='SIZE', default=lvm.LVM_SNAPSHOT_SIZE,
            help="create snapshot with given LV size (used to store writes during backup)")

    parser.add_option('--snapshot-wait', metavar='SECONDS', default=lvm.LVM_SNAPSHOT_WAIT, type='float',
            help="wait for snapshot to settle after unmounting")

    # defaults
    parser.set_defaults(
        debug_for   = [],
        loglevel    = logging.INFO,
    )

    # parse
    options, args = parser.parse_args(argv[1:])

    # configure
    logging.basicConfig(
        format  = '%(levelname)6s %(name)s : %(funcName)s : %(message)s',
        level   = options.loglevel,
    )

    # enable debugging for specific targets
    for target in options.debug_for :
        logging.getLogger(target).setLevel(logging.DEBUG)

    return options, args

def rsync_wrapper (command, options, local=False) :
    """
        Wrap given rsync command.

        Parses the command, the source path, and then executes rsync within the source path (which may be a special
        pseudo-path with additional handling).

            local       - the given command is a full local command, not an --server mode operation
    """

    # parse the rsync command sent by the client
    try :
        # path = the real source path
        rsync_cmd, rsync_options, path, srcdst = rsync.parse_command(command, 
                restrict_server     = not local,
                restrict_readonly   = options.readonly,
            )

    except RSyncCommandFormatError, e:
        log.error("invalid rsync command: %r: %s", command, e)
        return 2


    # parse source
    try :
        # parse the source path as given by the client, may be a real path or pseudo-path
        source = rsync.parse_source(path,
                restrict_path       = options.restrict_path,
                lvm_opts            = dict(size = options.snapshot_size, wait = options.snapshot_wait),
            )

    except RSyncCommandFormatError, e:
        log.error("invalid rsync source: %r: %s", path, e)
        return 2

    # noop?
    if options.noop :
        log.info("noop: %r -> %r: execute(%r, %r)", path, source, rsync_options, srcdst)
        return 0

    # execute
    try :
        # run rsync within the source (may perform additional stuff like snapshotting...)
        source.execute(rsync_options, srcdst)

    except InvokeError, e:
        log.error("%s failed: %d", e.cmd, e.exit)
        return e.exit


    # ok
    return 0

def main (argv) :
    """
        Run, with full argv
    """

    # global options + args
    options, args = parse_options(argv)

    # was a local command, not remote?
    local = False

    # from args (as given by `rsync -e pvlbackup-rsync-wrapper`) -> 'pvlbackup-rsync-wrapper <host> (<command> ...)'
    if options.given_command :
        host = args.pop(0)
        command_parts = args

        log.debug("host=%r, using command from args: %r", host, command_parts)
    
    # from env/--command
    elif options.command:
        # as given
        command_parts = shlex.split(options.command)

    # normal args
    elif args :
        command_parts = [argv[0]] + args
        local = True

        log.debug("using given rsync args: %r", command_parts)

    else :
        log.error("SSH_ORIGINAL_COMMAND not given")
        return 2

    # run
    try :
        return rsync_wrapper(command_parts, options, local)

    except Exception, e:
        log.error("Internal error:", exc_info=e)
        return 3

    # ok
    return 0

if __name__ == '__main__' :
    import sys

    sys.exit(main(sys.argv))

