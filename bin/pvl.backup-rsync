#!/usr/bin/python

"""
    SSH authorized_keys command="..." wrapper for rsync sender/server, with additional support for LVM snapshots.

    Testing:
        PYTHONPATH=. ./bin/pvl.backup-rsync -- -rlptx /etc/apache2 test/foo

        sudo PYTHONPATH=. ./bin/pvl.backup-rsync --command 'rsync --server --sender -ax . lvm:asdf:test' -vD

        sudo sh -c "PYTHONPATH=. rsync -e './bin/pvl.backup-rsync --debug -C --' -ax testing:lvm:asdf:test test/tmp"
"""

import pvl.args

from pvl.backup import __version__
from pvl.backup.rsync import RSyncCommandFormatError
from pvl.backup.invoke import InvokeError
from pvl.backup import rsync, lvm

import optparse
import shlex
import os
import logging

log = logging.getLogger('main')

def parse_options (argv) :
    """
        Parse command-line arguments.
    """

#    import sys; sys.stderr.write("%s\n" % (argv, ))

    parser = optparse.OptionParser(
            prog        = argv[0],

            # module docstring
            description = __doc__,
            version     = __version__,
    )

    # logging
    parser.add_option_group(pvl.args.parser(parser))

    #
    parser.add_option('-c', '--command',    metavar='CMD', default=os.environ.get('SSH_ORIGINAL_COMMAND'),
            help="Rsync command to execute")

    parser.add_option('-C', '--given-command', action='store_true', default=False,
            help="Use given command in `rsync -e '%prog -C --' ...` format")

    parser.add_option('-n', '--noop', action='store_true', default=False,
            help="Parse command, but do not execute")

    parser.add_option('-R', '--readonly',   action='store_true', default=False,
            help="Restrict to read/source mode")

    parser.add_option('-P', '--restrict-path', metavar='PATH', action='append',
            help="Restrict to given path prefix")

    parser.add_option('--allow-remote',     action='store_true', default=False,
            help="Allow remote rsync sources")

    parser.add_option('--sudo',             action='store_true',
            help="Execute rsync under sudo")

    # lvm options
    parser.add_option('-L', '--snapshot-size', metavar='SIZE', default=lvm.LVM_SNAPSHOT_SIZE,
            help="create snapshot with given LV size (used to store writes during backup)")

    parser.add_option('--snapshot-wait', metavar='SECONDS', default=lvm.LVM_SNAPSHOT_WAIT, type='float',
            help="wait for snapshot to settle after unmounting")

    parser.add_option('--snapshot-retry', metavar='RETRY', default=lvm.LVM_SNAPSHOT_RETRY, type='int',
            help="retry snapshot removal by given iterations")

    # defaults
    parser.set_defaults(
        restrict_path   = [],
    )

    # parse
    options, args = parser.parse_args(argv[1:])
    
    # general logging/etc
    pvl.args.apply(options)

    return options, args

def rsync_wrapper (options, command, local=False) :
    """
        Wrap given rsync command, parsing options/path, determining source, and running rsync in the source.

        Parses the command, the source path, and then executes rsync within the source path (which may be a special
        pseudo-path with additional handling).

            local       - the given command is a full local command, not an --server mode operation
    """

    # parse the rsync command sent by the client
    try :
        # path = the real source path
        rsync_cmd, rsync_options, path, srcdst = rsync.parse_command(command, 
                restrict_server     = not local,
                restrict_readonly   = options.readonly,
            )

    except RSyncCommandFormatError, e:
        log.error("invalid rsync command: %r: %s", command, e)
        return 2


    # parse source
    try :
        # parse the source path as given by the client, may be a real path or pseudo-path
        source = rsync.parse_source(path,
                restrict_paths      = options.restrict_path,
                allow_remote        = options.allow_remote,
                lvm_opts            = dict(
                    sudo    = options.sudo,
                    size    = options.snapshot_size, 
                    wait    = options.snapshot_wait,
                    retry   = options.snapshot_retry,
                ),
            )

    except RSyncCommandFormatError, e:
        log.error("invalid rsync source: %r: %s", path, e)
        return 2

    # noop?
    if options.noop :
        log.info("noop: %r -> %r: execute(%r, %r)", path, source, rsync_options, srcdst)
        return 0

    # execute
    try :
        # run rsync within the source (may perform additional stuff like snapshot...)
        source.execute(rsync_options, srcdst,
                sudo        = options.sudo,
        )

    except InvokeError, e:
        log.error("%s failed: %d", e.cmd, e.exit)
        return e.exit

    # ok
    return 0

def main (argv) :
    """
        Run, with full argv
    """

    # global options + args
    options, args = parse_options(argv)

    # was a local command, not remote?
    local = False

    # from args (as given by `rsync -e pvlbackup-rsync-wrapper`) -> 'pvlbackup-rsync-wrapper <host> (<command> ...)'
    if options.given_command :
        host = args.pop(0)
        command_parts = args

        log.debug("host=%r, using command from args: %r", host, command_parts)
    
    # from env/--command
    elif options.command:
        # as given
        command_parts = shlex.split(options.command)

    # normal args
    elif args :
        command_parts = [argv[0]] + args
        local = True

        log.debug("using given rsync args: %r", command_parts)

    else :
        log.error("SSH_ORIGINAL_COMMAND not given")
        return 2

    # run
    try :
        return rsync_wrapper(options, command_parts, local=local)

    except Exception, e:
        log.error("Internal error:", exc_info=e)
        return 3

    # ok
    return 0

if __name__ == '__main__' :
    import sys

    sys.exit(main(sys.argv))

