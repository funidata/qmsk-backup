#!/usr/bin/python

"""
    SSH authorized_keys command="..." wrapper for rsync.

    Testing goes something like:
        sudo sh -c "PYTHONPATH=. rsync -e './scripts/pvlbackup-rsync-wrapper --debug -C --' -ax testing:lvm:asdf:test test/tmp"
"""

from pvl.backup import __version__
from pvl.backup.rsync import RSyncCommandFormatError
from pvl.backup.invoke import InvokeError
from pvl.backup import rsync

import optparse
import shlex
import os
import logging

log = logging.getLogger()

# command-line options
options = None

def parse_options (argv) :
    """
        Parse command-line arguments.
    """

#    import sys; sys.stderr.write("%s\n" % (argv, ))

    parser = optparse.OptionParser(
            prog        = argv[0],

            # module docstring
            description = __doc__,
            version     = __version__,
    )

    # logging
    general = optparse.OptionGroup(parser, "General Options")

    general.add_option('-q', '--quiet',      dest='loglevel', action='store_const', const=logging.WARNING, help="Less output")
    general.add_option('-v', '--verbose',    dest='loglevel', action='store_const', const=logging.INFO,  help="More output")
    general.add_option('-D', '--debug',      dest='loglevel', action='store_const', const=logging.DEBUG, help="Even more output")

    parser.add_option_group(general)

    #
    parser.add_option('-c', '--command',    metavar='CMD', default=os.environ.get('SSH_ORIGINAL_COMMAND'),
            help="rsync command to execute")

    parser.add_option('-C', '--given-command', action='store_true', default=False,
            help="use given command in `rsync -e %prog` format")

    parser.add_option('-R', '--readonly',   action='store_true', default=False,
            help="restrict to read/source mode")

    parser.add_option('-P', '--restrict-path', metavar='PATH', default=False,
            help="restrict to given path prefix")

    # defaults
    parser.set_defaults(
        loglevel    = logging.WARNING,
    )

    # parse
    options, args = parser.parse_args(argv[1:])

    # configure
    logging.basicConfig(
        format  = '%(levelname)6s %(name)s : %(funcName)s : %(message)s',
        level   = options.loglevel,
    )

    return options, args

def rsync_wrapper (command, restrict='lvm:') :
    """
        Wrap given rsync command.

        Parses the command, the source path, and then executes rsync within the source path (which may be a special
        pseudo-path with additional handling).
    """

    try :
        # parse the rsync command sent by the client
        rsync_cmd, rsync_options, source_path, dest_path = rsync.parse_command(command, 
                restrict_readonly   = options.readonly,
            )

    except RSyncCommandFormatError, e:
        log.error("invalid rsync command: %r: %s", command, e)
        return 2

    # XXX: the real path is always given second..
    path = dest_path

    try :
        # parse the source path as given by the client, may be a real path or pseudo-path
        source = rsync.parse_source(path,
                restrict_path       = options.restrict_path,
            )

    except RSyncCommandFormatError, e:
        log.error("invalid rsync source: %r: %s", path, e)
        return 2

    try :
        # run rsync within the source (may perform additional stuff like snapshotting...)
        source.execute(rsync_options)

    except InvokeError, e:
        log.error("%s failed: %d", e.cmd, e.exit)
        return e.exit

    # ok
    return 0

def main (argv) :
    global options

    # global options + args
    options, args = parse_options(argv)

    # command required
    if options.given_command :
        # from args (as given by `rsync -e pvlbackup-rsync-wrapper`) -> 'pvlbackup-rsync-wrapper <host> (<command> ...)'
        host = args.pop(0)
        command_parts = args

        log.debug("using command from args: %r", command_parts)

    # args
    elif args :
        log.error("No arguments are handled")
        return 2

    elif options.command:
        # as given
        command_parts = shlex.split(options.command)

    else :
        log.error("SSH_ORIGINAL_COMMAND not given")
        return 2


    # run
    try :
        return rsync_wrapper(command_parts)

    except Exception, e:
        log.error("Internal error:", exc_info=e)
        return 3

    # ok
    return 0

if __name__ == '__main__' :
    import sys

    sys.exit(main(sys.argv))

